# frozen_string_literal: true

require "moku/policy"

module Moku

  # Authorizes activities from the loaded role information. It delegates
  # to the policies generated by the inserted policy_factory.
  # @param global [Hash<String, Array>] Hash of role:usernames pairs.
  # @param instances [Hash<String, Hash<String,Array>>] The keys of the
  #   top level hash are the instance names, each of which has as its
  #   value a hash of role:usernames pairs.
  # @param policy_factory [PolicyFactory] Generates policies that actually
  #   govern the final behavior of the authorization module.
  class AuthService
    def initialize(global: {}, instances: {}, policy_factory: Policy)
      @global = global
      @instances = instances
      @policy_factory = policy_factory
    end

    def authorized?(user:, entity:, action:)
      return false unless user && entity && action

      policy(user, entity).authorized?(action)
    end

    private

    def policy(user, entity)
      policy_factory.for(roles(user, entity.name))
    end

    def roles(user_name, instance_name)
      merged_role_users(instance_name)
        .select {|_role, users| users.include?(user_name) }
        .keys
        .map(&:to_sym)
    end

    def merged_role_users(instance_name)
      global.merge(instances.fetch(instance_name, {})) do |_key, oldval, newval|
        oldval + newval
      end
    end

    attr_reader :global, :instances, :policy_factory
  end
end
